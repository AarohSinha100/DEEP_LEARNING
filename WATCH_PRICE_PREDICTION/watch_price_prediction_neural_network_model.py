# -*- coding: utf-8 -*-
"""WATCH_PRICE_PREDICTION_NEURAL_NETWORK_MODEL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QBZU_kTpoTqJWKlHyQ0WAz5mUemj6RaO
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import tensorflow as tf

watch_prices = pd.read_csv("Smart watch prices.csv")
watch_prices.head()

watch_prices.info()

watch_prices.isnull().sum()

watch_prices.dropna(inplace=True,axis=0)

watch_prices.isnull().sum()

watch_prices.drop(["Operating System","Display Type","Model","Brand"],axis=1,inplace=True)

watch_prices.head(2)

watch_prices["Connectivity"].value_counts() #isprr kaam krna hoga

watch_prices_1 = pd.get_dummies(watch_prices[watch_prices.columns[6:8]])
watch_prices_1.drop(["GPS_No","NFC_No"],axis=1,inplace=True) 
watch_prices_1.columns = ["GPS","NFC"]

watch_prices["GPS"] = watch_prices_1["GPS"]
watch_prices["NFC"] = watch_prices_1["NFC"]
watch_prices.head()

watch_prices["Heart Rate Monitor"] = pd.get_dummies(watch_prices["Heart Rate Monitor"])

watch_prices.head()

watch_prices["Battery Life (days)"].hist(figsize=(20,7))

sns.countplot(x="GPS",data=watch_prices)

sns.countplot(x="NFC",data=watch_prices)

watch_prices.head(2)

watch_prices["Price (USD)"].head(2)

watch_prices["Price"] = watch_prices["Price (USD)"].apply(lambda x: int(x.replace(",","").split("$")[1]))

watch_prices.drop("Price (USD)",axis=1,inplace=True)
watch_prices.head(2)

def cellular(value):
  m = value.split(",")
  if " Cellular" in m:
    return 1
  else:
    return 0

watch_prices["Cellular"] = watch_prices["Connectivity"].apply(lambda x: cellular(x))

watch_prices.head()

watch_prices.drop("Connectivity",axis=1,inplace=True)

watch_prices.head()

int(watch_prices["Resolution"].iloc[0].split("x")[0])

watch_prices["Resolution"].value_counts()
#less than 326x326 - poor
#between 326x326 and 430x430 - med
#above 430x430 - great!

def resolution(value):
  m = value.split("x")
  for i in range(len(m)):
    m[i] = int(m[i])
  
  if m[0]*m[1]<=106276:
    return 0
  elif m[0]*m[i]>106276 and m[0]*m[i]<=184900:
    return 1
  elif m[0]*m[i]>184900:
    return 2

watch_prices["Resolution"] =  watch_prices["Resolution"].apply(lambda x: resolution(x))

watch_prices.head()

watch_prices["Water Resistance (meters)"].value_counts()

def water_resistance(value):
  if value == 'Not specified':return 0
  value = value.replace(".","")
  value = int(value)
  if value>=60:
    return 2
  elif value>=30 and value<60:
    return 1
  else:
    return 0

watch_prices["Water Resistance (meters)"] = watch_prices["Water Resistance (meters)"].apply(lambda x: water_resistance(x))

watch_prices.head()

watch_prices["Battery Life (days)"].value_counts()

def batterylife(value):
  if value=="Unlimited":
    return 1000
  elif value=="48 hours":
    return 2
  elif value=="1.5":
    return 1
  else:
    return int(value)

watch_prices["Battery Life (days)"] = watch_prices["Battery Life (days)"].apply(lambda x: batterylife(x))

watch_prices.head()

plt.figure(figsize=(15,7))
sns.heatmap(watch_prices.corr(),annot=True)

"""## Linear Regression Model"""

from sklearn.model_selection import train_test_split

X = watch_prices.drop("Price",axis=1)
y = watch_prices["Price"]

X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=101)

from sklearn.linear_model import LinearRegression
lr = LinearRegression()

lr.fit(X_train, y_train)

lr.coef_, lr.intercept_

preds = lr.predict(X_test)

from sklearn import metrics
print("MAE - ",metrics.mean_absolute_error(y_test, preds))
print("MSE - ",metrics.mean_squared_error(y_test,preds))

"""## NEURAL NETWORK MODEL"""

tf.random.set_seed(101)

model_1 = tf.keras.Sequential([
    tf.keras.layers.Dense(1)
])

model_1.compile(loss=tf.keras.losses.mae,
                optimizer = tf.keras.optimizers.SGD(),
                metrics=["mae"])

history_1 = model_1.fit(X_train, y_train, epochs=50)

#Model 2
model_2 = tf.keras.Sequential([
    tf.keras.Input(shape=(8,1)),
    tf.keras.layers.Dense(100,activation="relu"),
    tf.keras.layers.Dense(10,activation="relu"),
    tf.keras.layers.Dense(1)
])

model_2.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.Adam(lr=0.01),
                metrics=["mae"])

history_2 = model_2.fit(X_train,y_train, epochs=100)

preds = model_2.predict(X_test)
preds

tf.expand_dims(y_test,axis=1).shape, tf.constant(preds).shape

X_train.shape

model_2.evaluate(y_test,preds)

"""### Creating a new Model"""

tf.random.set_seed(42)

model_3 = tf.keras.Sequential([
    tf.keras.Input(shape=(8,1)),
    tf.keras.layers.Dense(1000,activation="relu"),
    tf.keras.layers.Dense(100,activation="relu"),
    tf.keras.layers.Dense(10,activation="relu"),
    tf.keras.layers.Dense(1)
])

model_3.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.Adam(lr=0.001),
                metrics=["mae"])

history_3 = model_3.fit(X_train, y_train, epochs=200,verbose=0)

preds_3 = model_3.predict(X_test)

model_3.evaluate(y_test, preds_3)

m = [1.2,1.0,1.0,24.0,1.0,1.0,1.0,0.0]
#Predicting by our neural network model
predicted_price = model_3.predict(tf.expand_dims(m,axis=1))
predicted_price #149?

watch_prices.iloc[40]

watch_prices.head(2)

"""## Model 4 (Probably we are maing too complex model)"""

tf.random.set_seed(42)

model_4 = tf.keras.Sequential([
    tf.keras.Input(shape=(8,1)),
    tf.keras.layers.Dense(40,activation="relu"),
    tf.keras.layers.Dense(10,activation="relu"),
    tf.keras.layers.Dense(10,activation="relu"),
    tf.keras.layers.Dense(1)
])

model_4.compile(loss=tf.keras.losses.mae,
                optimizer=tf.keras.optimizers.Adam(lr=0.001),
                metrics=["mae"])

history_4 = model_4.fit(X_train,y_train,epochs=500,verbose=0)

preds_4 = model_4.predict(X_test)
model_4.evaluate(y_test,preds)



